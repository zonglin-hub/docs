是的，有多种方式可以让这个输出更易读。以下是几种优化方案：


```bash
> ps aux | grep obsidian
zonglin  1418693  0.0  0.0   3580  2044 ?        S    09:37   0:00 bwrap --args 39 -- obsidian.sh
zonglin  1418707  0.0  0.0   3680  1468 ?        S    09:37   0:00 bwrap --args 39 -- obsidian.sh
zonglin  1418708  0.0  0.0   7940  3508 ?        S    09:37   0:00 /bin/sh /app/bin/obsidian.sh
zonglin  1418720  9.4  1.5 1216440364 239404 ?   Sl   09:37   0:02 /app/obsidian
zonglin  1418727  0.0  0.3 34062812 50564 ?      S    09:37   0:00 /app/obsidian --type=zygote --no-zygote-sandbox
zonglin  1418734  0.0  0.0   3580  2044 ?        Ss   09:37   0:00 bwrap --args 41 -- /app/bin/zypak-helper child - /app/obsidian --type=zygote
zonglin  1418743  0.0  0.0   3676  1468 ?        S    09:37   0:00 bwrap --args 41 -- /app/bin/zypak-helper child - /app/obsidian --type=zygote
zonglin  1418744  0.0  0.3 34065512 52508 ?      S    09:37   0:00 /app/obsidian --type=zygote
zonglin  1418778  7.4  0.9 34541352 143980 ?     Sl   09:37   0:02 /app/obsidian --type=gpu-process --enable-crash-reporter=fe825fe4-2c47-44a4-bbc7-40c3192e118e,no_channel --user-data-dir=/home/zonglin/.var/app/md.obsidian.Obsidian/config/obsidian --gpu-preferences=UAAAAAAAAAAgAAAEAAAAAAAAAAAAAAAAAABgAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAABAAAAAAAAAAEAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAA --shared-files --field-trial-handle=3,i,5822200609262840771,2417128868701724030,262144 --enable-features=SharedArrayBuffer --disable-features=SpareRendererForSitePerProcess --variations-seed-version
zonglin  1418784  2.0  0.4 33866712 70580 ?      Sl   09:37   0:00 /app/obsidian --type=utility --utility-sub-type=network.mojom.NetworkService --lang=zh-CN --service-sandbox-type=none --enable-crash-reporter=fe825fe4-2c47-44a4-bbc7-40c3192e118e,no_channel --user-data-dir=/home/zonglin/.var/app/md.obsidian.Obsidian/config/obsidian --standard-schemes=app --secure-schemes=app --fetch-schemes=app --streaming-schemes=app --code-cache-schemes=app --shared-files=v8_context_snapshot_data:100 --field-trial-handle=3,i,5822200609262840771,2417128868701724030,262144 --enable-features=SharedArrayBuffer --disable-features=SpareRendererForSitePerProcess --variations-seed-version
zonglin  1418792 21.8  2.0 1219989648 315408 ?   Sl   09:37   0:06 /app/obsidian --type=renderer --enable-crash-reporter=fe825fe4-2c47-44a4-bbc7-40c3192e118e,no_channel --user-data-dir=/home/zonglin/.var/app/md.obsidian.Obsidian/config/obsidian --standard-schemes=app --secure-schemes=app --fetch-schemes=app --streaming-schemes=app --code-cache-schemes=app --app-path=/app/resources/app.asar --no-sandbox --no-zygote --node-integration-in-worker --lang=zh-CN --num-raster-threads=4 --enable-main-frame-before-activation --renderer-client-id=4 --time-ticks-at-unix-epoch=-1764061175821075 --launch-time-ticks=59882530418 --shared-files=v8_context_snapshot_data:100 --field-trial-handle=3,i,5822200609262840771,2417128868701724030,262144 --enable-features=SharedArrayBuffer --disable-features=SpareRendererForSitePerProcess --variations-seed-version
zonglin  1419276  0.0  0.0   9440  2304 pts/0    S+   09:38   0:00 grep --color=auto obsidian

```

## 1. 使用 `ps` 的格式化输出（推荐）

```bash
ps -eo user,pid,%cpu,%mem,start,time,comm --sort -pid | grep obsidian
```

或者更简洁的格式：
```bash
ps -eo pid,user,%cpu,%mem,comm --sort -pid | grep obsidian | column -t
```

## 2. 使用 `pgrep` 和 `ps` 结合

```bash
# 先找到所有 Obsidian 相关的 PID
pgrep -f obsidian | xargs ps -o user,pid,%cpu,%mem,start,time,command -p
```

## 3. 创建自定义函数

在 `~/.bashrc` 中添加：
```bash
psgrep() {
    if [ $# -eq 0 ]; then
        echo "Usage: psgrep <process_name>"
        return 1
    fi
    ps -eo user,pid,%cpu,%mem,start,time,comm --sort -pid | grep -i "$1" | column -t
}
```

然后使用：
```bash
psgrep obsidian
```

## 4. 使用 `htop` 进行交互式查看

```bash
htop -p $(pgrep -d, -f obsidian)
```

## 5. 最清晰的输出格式

```bash
ps -p $(pgrep -d, -f obsidian) -o user,pid,%cpu,%mem,start,time,command --forest
```

## 6. 一次性优化命令

对于你当前的输出，这个命令效果最好：
```bash
ps -eo pid,user,%cpu,%mem,start,time,comm,args --sort -pid | grep obsidian | head -n -1 | column -t
```

## 示例输出效果

使用 `column -t` 后的效果：
```
USER     PID    %CPU  %MEM  START   TIME     COMMAND
zonglin  672780 0.0   0.0   01:16   0:00     sh
zonglin  672781 1.4   1.6   01:16   0:06     obsidian
zonglin  672784 0.0   0.3   01:16   0:00     obsidian
```

**建议使用第3种方法**（自定义函数），这样以后只需要输入 `psgrep obsidian` 就能获得格式化的清晰输出。

---

理解了！你想看完整的命令行输出但希望排版更清晰。以下是几种保持完整信息但提升可读性的方法：

## 1. 使用 `column` 命令对齐（推荐）

```bash
ps aux | grep obsidian | head -n -1 | column -t
```

这会保持所有信息，但用制表符对齐，效果类似：
```
zonglin  672780  0.0  0.0   2800  1616  ?  Ss  01:16  0:00  sh -c /opt/Obsidian/obsidian --ozone-platform=wayland
zonglin  672781  1.4  1.6   1460064372 254616  ?  Sl  01:16  0:06  /opt/Obsidian/obsidian --ozone-platform=wayland
```

## 2. 按列分隔显示

```bash
ps aux | grep obsidian | head -n -1 | awk '{
    printf "%-8s %-6s %-4s %-4s %-8s %-6s %-2s %-5s %-8s ", $1,$2,$3,$4,$5,$6,$7,$8,$9
    for(i=10;i<=NF;i++) printf "%s ", $i
    printf "\n"
}'
```

## 3. 带颜色高亮显示

```bash
ps aux | grep obsidian | head -n -1 | while read line; do
    echo "$line" | sed -E 's/(^[^ ]+ +[^ ]+ +[^ ]+ +[^ ]+ +[^ ]+ +[^ ]+ +[^ ]+ +[^ ]+ +[^ ]+ )(.*)/\x1b[33m\1\x1b[0m\x1b[36m\2\x1b[0m/'
done
```

## 4. 分组显示（进程树视图）

```bash
ps -ef --forest | grep obsidian | head -n -1
```

## 5. 最清晰的完整信息展示

```bash
ps aux | grep obsidian | head -n -1 | while read line; do
    # 提取基本信息
    user=$(echo "$line" | awk '{print $1}')
    pid=$(echo "$line" | awk '{print $2}')
    cpu=$(echo "$line" | awk '{print $3}')
    mem=$(echo "$line" | awk '{print $4}')
    
    # 提取完整命令
    command=$(echo "$line" | awk '{$1=$2=$3=$4=$5=$6=$7=$8=$9=$10=""; print $0}' | sed 's/^ *//')
    
    printf "\033[1;32m%-8s\033[0m \033[1;34m%-6s\033[0m CPU:%-4s MEM:%-4s\n" "$user" "$pid" "$cpu" "$mem"
    printf "  \033[0;33m%s\033[0m\n\n" "$command"
done
```

## 6. 如果你想要表格形式但保留完整命令

```bash
ps aux | grep obsidian | head -n -1 | sed 's/  */\t/g' | column -t -s $'\t'
```

## 7. 交互式查看完整命令

```bash
# 先保存到文件，然后用 less 查看（可以左右滚动）
ps aux | grep obsidian > /tmp/obsidian_processes.txt
less -S /tmp/obsidian_processes.txt  # -S 参数防止换行
```

在 less 中：
- 按 `→` 向右滚动查看完整命令
- 按 `q` 退出

**推荐使用第1种或第5种方法**，它们既保持了所有原始信息，又大大提升了可读性。

这个效果可以通过编写一个格式化脚本来实现。以下是几种方法：

---

```
我们想要将长命令行参数换行显示，并且对齐。但是注意，我们不想改变其他行的显示方式，只对那些命令行特别长的行进行换行，并且保持前10个字段在同一行，然后将后面的每个参数换行显示，并缩进对齐。

但是，注意：ps aux的输出中，前10个字段是固定的，第11个字段开始是命令和参数。但是，由于命令和参数中可能包含空格，所以我们不能简单按照空格分割。

不过，我们可以注意到，ps aux的输出中，前10个字段的格式是固定的，每个字段之间用空格分隔，但是字段内部可能有空格（比如时间字段），所以我们需要更精确的方法。

但是，实际上，ps aux的输出格式是：  
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND

其中，前10个字段是固定的，然后剩下的部分都是COMMAND。所以我们可以提取前10个字段，然后剩下的部分就是完整的命令行。

我们可以这样做：

1. 读取每一行（除了最后一行grep自身）
    
2. 将前10个字段提取出来，剩下的部分作为命令行
    
3. 对命令行进行换行处理，比如每80个字符换行，或者按照参数换行（按照空格分割参数，然后逐个排列）
    

但是，你给出的示例中是按照参数换行的，每个参数一行，并且缩进对齐。

所以，我们可以这样：  
对于每一行，我们提取前10个字段，然后将命令行部分按空格分割成多个参数，然后将前10个字段显示在第一行，然后将每个参数显示在后续行，并缩进到与第一行命令的起始位置对齐。

但是，注意：有些参数是连续的，比如--enable-crash-reporter=...，我们不想把它分开。

所以，我们按照参数分割，即按照空格分割，但是注意，命令行参数中可能包含带空格的参数（用引号括起来的），但是我们这里简单处理，按照空格分割。

步骤：

1. 使用awk提取前10个字段和剩余的字段  
    注意：ps aux的输出中，前10个字段之间可能有一个或多个空格，所以我们使用awk的默认字段分割（空格），但是前10个字段之后的所有字段都是命令部分。
    
2. 我们可以用awk的for循环来重建前10个字段，然后剩下的部分从第11字段开始。
    

但是，注意：有些行的字段数可能超过11，因为命令有多个参数。

我们可以这样写一个脚本：

由于ps aux的输出中，前10个字段是固定的，我们可以用以下方法：

假设我们有一个文件包含ps aux的输出，我们可以用以下命令处理：

但是，我们不想处理最后一行（grep自身），所以先用head -n -1去掉最后一行。

然后，对每一行进行处理：

用awk：  
{  
# 打印前10个字段，不带换行  
for(i=1; i<=10; i++) {  
printf "%s ", $i  
}  
# 然后打印换行，然后处理后面的参数  
printf "\n"  
# 然后从第11个字段开始，每个参数换行打印，并缩进  
for(i=11; i<=NF; i++) {  
printf " %s\n", $i  
}  
}

但是，这样缩进是固定的，而且不对齐。我们想要对齐到第一行命令的起始位置。

我们可以计算第一行命令的起始位置：即前10个字段的长度之和加上9个空格（因为字段之间有一个空格，但是printf "%s "会每个字段后打印一个空格，所以实际上我们打印了10个字段，有9个空格，然后最后一个字段后面也有一个空格，所以总共是10个字段和10个空格？不对，我们打印10个字段，每个字段后面一个空格，所以总共是10个字段和10个空格，但是最后一个空格我们不需要，所以我们可以调整一下，前10个字段我们用一个字符串表示，然后计算这个字符串的长度。

但是，注意：终端中每个字符的宽度不一定相同，但是我们对齐空格，所以没问题。

我们可以这样做：

首先，将前10个字段拼接成一个字符串，每个字段后面加一个空格，然后计算这个字符串的长度，作为缩进的宽度。

但是，注意：第一行我们打印了前10个字段，然后我们换行了，第二行开始我们打印缩进，然后打印参数。

但是，我们想要的效果是：第一行打印前10个字段，然后如果命令行有参数，就从第二行开始，每个参数一行，并且参数前面缩进到与第一行命令的起始位置对齐。

但是，第一行命令的起始位置实际上是第10个字段后面的位置，也就是前10个字段的字符串长度。

但是，我们打印前10个字段的时候，每个字段后面有一个空格，所以字符串长度是：每个字段的长度之和 + 10（因为10个空格）。

然后，我们缩进的时候，就缩进到这个长度，这样第二行开始的内容就会对齐到第一行命令的起始位置。

但是，注意：第一行我们打印了前10个字段和10个空格，然后我们换行了，所以第二行我们打印空格，数量为前10个字段的字符串长度（包括空格），然后打印参数。

但是，实际上，第一行我们打印的是前10个字段，然后我们并没有打印命令行的任何参数，所以第一行只有前10个字段，然后换行。然后从第二行开始，我们打印缩进，然后打印第一个参数，然后换行，然后同样的缩进，打印第二个参数，以此类推。

但是，这样看起来，第一行是前10个字段，然后下面每一行是一个参数，并且对齐。

但是，我们也可以选择将第一个参数放在第一行，如果第一个参数很短，并且整个命令行参数不多，我们可以不换行，但是这里我们要求全部换行。

所以，我们可以用以下脚本：

注意：我们使用awk来处理，但是awk中每个字段的长度可以通过length函数获取。

但是，我们也可以直接拼接字符串，然后计算长度。

我们尝试：

由于我们是在终端中，所以我们可以用环境变量来控制宽度，但是这里我们不考虑终端宽度，直接每个参数一行。

脚本如下：

注意：我们去掉最后一行grep，然后处理每一行。

我们可以写一个awk脚本：

bash

ps aux | grep obsidian | head -n -1 | awk '
{
    # 前10个字段
    base = ""
    for(i=1; i<=10; i++) {
        if (i==10) {
            printf "%s", $i
            base = base $i
        } else {
            printf "%s ", $i
            base = base $i " "
        }
    }
    printf "\n"
    # 计算base的长度，用于缩进
    indent = length(base)
    # 从第11个字段开始，打印每个参数，并缩进
    for(i=11; i<=NF; i++) {
        printf "%*s%s\n", indent, " ", $i
    }
}'

但是，这样可能会有一个问题：如果命令行参数中有多个连续空格，那么awk会将其分割成多个字段，但是实际上，在ps aux中，命令行参数中的多个空格会被保留，但是awk默认会将其视为分隔符，所以我们会丢失空格。

所以，我们不应该用awk的默认字段分割，而是应该知道ps aux的输出中，前10个字段是固定的，然后第11字段开始直到行尾都是命令。

我们可以调整一下，使用substr来提取第11字段之后的部分。

但是，我们也可以设置awk的字段分隔符为整个行的模式，但是这样比较复杂。

另一种方法：我们已知前10个字段，但是我们可以用`$0`来从第11字段开始提取，但是awk中我们无法直接知道第10个字段结束的位置。

我们可以这样：先记录整个行，然后依次去掉前10个字段，然后剩下的就是命令行。

但是，我们可以用以下技巧：

将前10个字段打印出来，然后命令行部分我们按原样输出，但是我们要将命令行分割成多个参数，按照空格分割，但是注意，命令行参数中可能包含空格，如果我们按照空格分割，就会破坏参数。

所以，我们不应该分割参数，而是应该将整个命令行作为一个字符串，然后按照一定的宽度换行，并且缩进。

但是，你给出的示例中是按参数换行的，也就是说，每个参数单独一行。

所以，我们假设参数之间是用空格分隔的，并且参数内部没有空格（或者有空格但用引号括起来了，但是我们不处理引号，因为这种情况在ps aux中很少见，而且ps aux显示的命令行参数已经是解析后的）。

所以，我们按照空格分割参数，然后每个参数一行。

但是，如果参数中有空格，那么就会被分成多个字段，这样就会出错。

所以，我们换一种思路：我们不按照awk的字段分割，而是按照整个命令行字符串，然后从第一个参数开始，逐个参数打印，但是我们需要知道参数的分界是空格，但是注意空格可能被引号包围。

这实际上是一个复杂的问题，我们简单处理，按照空格分割，因为大多数情况下，参数没有空格。

所以，我们按照上面的方法，但是注意，如果参数中有空格，那么就会被打散，所以这种方法不完美。

但是，考虑到ps aux的输出中，命令行参数中的空格确实会分割成多个字段，所以我们按照字段处理实际上就是按照空格分割的。

所以，我们按照上面的方法。

但是，我们也可以不分割参数，而是将命令行部分作为一个整体，然后按照固定的宽度（比如80个字符）换行，并缩进。

这样更简单，而且不会破坏参数。

所以，我们调整一下：

我们提取命令行部分（第11字段到行尾），然后按照固定的宽度换行，并缩进。

我们可以用awk的substr和while循环来按照宽度截取。

步骤：

1. 提取前10个字段，并打印，然后换行。
    
2. 提取命令行部分：从第11字段开始，我们实际上可以这样：`command = substr($0, index($0, $11))`，但是注意，第11字段可能不存在，所以我们要判断一下。
    

但是，我们也可以这样：我们已知前10个字段，我们可以记录第10个字段之后的位置。

我们可以用`$0`减去前10个字段和它们之间的空格，但是我们可以用以下方法：

我们用一个变量`base`记录前10个字段的字符串，然后命令行部分就是`$0`减去`base`，但是注意，`base`中我们每个字段后面加了一个空格，所以`base`的长度就是前10个字段的长度和+10个空格。

但是，实际上，我们打印`base`的时候，最后一个字段后面也有一个空格，所以命令行部分应该是从`length(base)+1`开始？不对，因为`base`就是前10个字段加上空格，所以命令行部分应该是`substr($0, length(base)+1)`。

但是，我们打印前10个字段的时候，我们用的是`printf`，没有改变`$0`，所以我们可以用`substr($0, length(base)+1)`来获取命令行部分。

然后，我们将命令行部分按照固定宽度（比如80个字符）换行，并缩进。

但是，我们想要的效果是每个参数一行，而不是固定宽度。所以，我们还是按照参数换行。

考虑到复杂性，我们折中：按照固定宽度换行，这样可能在一个参数中间换行，但是可以保证不会破坏参数（因为参数中间换行只是显示问题，不会改变参数的含义）。

所以，我们选择按照固定宽度换行。

我们可以这样：

我们设定一个最大行宽，比如120个字符，然后缩进宽度为`length(base)`。

然后，我们将命令行字符串按照最大行宽减去缩进宽度的长度进行换行。

但是，我们也可以直接按照终端宽度，但是这里我们假设终端足够宽，我们按照100个字符的宽度换行。

所以，我们修改脚本：

我们使用`fold`命令来换行，但是注意，`fold`命令不会缩进。

所以，我们可以用awk来实现换行并缩进。

我们写一个awk函数来换行并缩进：

由于我们已经在awk中，我们可以自己处理字符串。

步骤：

1. 打印前10个字段
    
2. 获取命令行部分
    
3. 将命令行部分按照固定宽度（比如100）换行，每行前面加上缩进（缩进量为前10个字段的长度）
    

但是，注意：第一行我们已经打印了前10个字段，所以命令行部分从第二行开始，每行都要缩进。

所以，我们可以这样：

我们定义一个变量`width=100`，然后`indent=length(base)`，然后每行的最大长度就是`width - indent`。

但是，我们也可以不考虑宽度，而是按照参数换行，但是参数换行比较复杂，我们这里按照固定宽度。

所以，我们按照固定宽度换行：

脚本如下：

bash

ps aux | grep obsidian | head -n -1 | awk '
{
    # 前10个字段
    base = ""
    for(i=1; i<=10; i++) {
        if (i==10) {
            printf "%s", $i
            base = base $i
        } else {
            printf "%s ", $i
            base = base $i " "
        }
    }
    printf "\n"
    # 计算base的长度，用于缩进
    indent = length(base)
    # 获取命令行部分
    command = substr($0, length(base)+1)
    # 现在将command按照固定宽度换行，每行最大宽度为100，缩进为indent
    # 我们按照100个字符的宽度，但是要减去缩进，所以每行最多100-indent个字符
    width = 100
    len = length(command)
    pos = 1
    while (pos <= len) {
        # 取子串，从pos开始，长度为width-indent
        # 但是要注意，不能断在单词中间，我们这里简单处理，直接截断
        # 如果想在空格处断行，可以稍微复杂一点，但是这里我们直接截断
        segment = substr(command, pos, width-indent)
        printf "%*s%s\n", indent, " ", segment
        pos += (width - indent)
    }
}'

但是，这样可能会在单词中间断行，所以我们可以改进一下，在最近的空格处断行。

但是，为了简单，我们直接截断。

如果你希望在每个参数处换行，那么我们就必须按照参数换行，但是这样可能会遇到参数内部空格的问题。

考虑到时间，我们按照参数换行，并假设参数内部没有空格（或者有空格但用引号括起来的我们不管，因为ps aux的输出已经将参数用空格分隔了）。

所以，我们回到最初的方法，按照空格分割参数，然后每个参数一行。

但是，我们如何获取命令行参数？我们使用从第11字段开始直到最后一个字段。

所以，我们这样：

我们打印前10个字段，然后换行，然后从第11字段开始，每个字段打印一行，并缩进。

这样，每个参数一行，并且对齐。

但是，如果参数内部有空格，那么它会被分成多个字段，这样就会多行，但是实际上，这个参数是一个整体。

所以，我们只能希望ps aux输出的命令行参数中，没有空格，或者空格被转义了。

实际上，ps aux输出的命令行参数中，如果参数有空格，那么它会显示为多个字段，所以我们无法区分。

所以，我们只能按照字段处理，每个字段一行。

所以，我们使用最开始的脚本：

bash

ps aux | grep obsidian | head -n -1 | awk '
{
    # 前10个字段
    base = ""
    for(i=1; i<=10; i++) {
        if (i==10) {
            printf "%s", $i
            base = base $i
        } else {
            printf "%s ", $i
            base = base $i " "
        }
    }
    printf "\n"
    # 计算base的长度，用于缩进
    indent = length(base)
    # 从第11个字段开始，打印每个参数，并缩进
    for(i=11; i<=NF; i++) {
        printf "%*s%s\n", indent, " ", $i
    }
}'

这样，每个参数一行，并且对齐到第一行命令的起始位置。

但是，注意，第一行命令的起始位置实际上是第10个字段的结束，也就是base字符串的结束位置。

我们测试一下。

但是，你给出的示例中，有些行的参数非常多，我们这样处理就会每个参数一行，并且对齐。

所以，我们这样处理。

最后，我们还要注意，最后一行是grep命令，我们使用`head -n -1`去掉了，所以不需要处理。

我们运行一下这个命令，看看效果。

如果效果不好，我们可以调整。

另外，我们也可以考虑将缩进调整为固定缩进，比如40个字符，这样不管前10个字段多长，我们都缩进40个字符，这样看起来更整齐。

但是，这样可能会对不齐，因为每个行的前10个字段长度不同。

所以，我们选择动态缩进。

我们试试看。

注意：如果终端宽度不够，可能换行，但是我们是每个参数一行，所以不会出现一行很长的情况。

所以，我们按照这个脚本输出。

但是，我们也可以将缩进设置为固定值，比如40，这样所有行的参数都对齐到第40个字符，这样看起来更整齐，但是会浪费空间。

我们可以这样：

我们计算所有行中前10个字段的最大长度，然后按照最大长度来缩进，这样所有行的参数都会对齐到同一列。

但是，这样需要先处理所有行，然后找到最大长度，然后再输出，比较麻烦。

所以我们先按照动态缩进。

现在，我们输出这个脚本。

注意：我们是在bash中，所以可以直接运行。

但是，我们也可以写成一个函数，放在.bashrc中。

我们把这个函数叫做psfmt，然后就可以这样用：`ps aux | grep obsidian | psfmt`

但是，我们这里先直接运行。

我们试试看。

如果效果不理想，我们可以调整。

另外，我们也可以考虑使用`ps -o`来自定义输出格式，然后结合我们的换行方法，但是这里我们已经用了ps aux。

所以，我们按照上面的命令。

我们运行一下，看看效果。

注意：我们这里去掉了grep自身，所以不会显示grep那一行。

但是，如果你想要保留grep自身，可以去掉`head -n -1`，然后我们可以在awk中跳过grep，但是这里我们已经去掉了。

所以，我们直接运行。

如果遇到问题，我们再调整。

现在，我们输出这个命令。
```

## 方法1：使用 awk 脚本实现

创建一个格式化脚本 `format-ps.awk`：

```bash
#!/bin/awk -f

# 跳过 grep 进程本身
/grep --color=auto/ { next }

{
    # 提取前9个字段（用户到时间）
    user = $1
    pid = $2
    cpu = $3
    mem = $4
    vsz = $5
    rss = $6
    tty = $7
    stat = $8
    start = $9
    time = $10
    
    # 打印基本信息行
    printf "%-8s %-6s %-4s %-4s %-8s %-6s %-2s %-5s %-8s %-8s ", 
           user, pid, cpu, mem, vsz, rss, tty, stat, start, time
    
    # 构建命令部分
    cmd = ""
    for(i=11; i<=NF; i++) {
        cmd = cmd $i " "
    }
    
    # 如果命令很短，直接打印在一行
    if(length(cmd) < 80) {
        print cmd
    } else {
        # 否则分行打印
        print substr(cmd, 1, index(cmd, " ") - 1)  # 第一个单词
        
        # 分割剩余部分
        rest = substr(cmd, index(cmd, " ") + 1)
        split(rest, args, " ")
        
        indent = "                                                                   "
        for(i in args) {
            if(args[i] != "") {
                print indent args[i]
            }
        }
    }
    print ""  # 空行分隔
}
```

然后使用：
```bash
ps aux | grep obsidian | awk -f format-ps.awk
```

## 方法2：使用 Python 脚本（推荐）

创建 `format_ps.py`：

```python
#!/usr/bin/env python3
import sys
import re

def main():
    lines = sys.stdin.readlines()
    
    for line in lines:
        line = line.strip()
        
        # 跳过 grep 进程
        if 'grep --color=auto' in line:
            continue
            
        # 使用正则表达式匹配 ps aux 的格式
        match = re.match(r'^(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(.*)$', line)
        
        if match:
            user, pid, cpu, mem, vsz, rss, tty, stat, start, time, command = match.groups()
            
            # 打印基本信息
            print(f"{user:8} {pid:6} {cpu:4} {mem:4} {vsz:8} {rss:6} {tty:2} {stat:5} {start:8} {time:8} ", end='')
            
            # 处理命令部分
            parts = command.split()
            if len(parts) == 0:
                print()
                continue
                
            # 第一个部分
            print(parts[0])
            
            # 剩余部分分行显示
            indent = " " * 70
            for part in parts[1:]:
                print(f"{indent}{part}")
                
            print()  # 空行

if __name__ == "__main__":
    main()
```

使用：
```bash
chmod +x format_ps.py
ps aux | grep obsidian | ./format_ps.py
```

## 方法3：一行命令实现（简化版）

```bash
ps aux | grep obsidian | grep -v grep | while read line; do
    # 提取基本信息
    basic_info=$(echo "$line" | awk '{for(i=1;i<=10;i++) printf "%s ", $i; print ""}')
    command_part=$(echo "$line" | awk '{$1=$2=$3=$4=$5=$6=$7=$8=$9=$10=""; print $0}' | sed 's/^ *//')
    
    # 分割命令
    first_word=$(echo "$command_part" | awk '{print $1}')
    rest_words=$(echo "$command_part" | awk '{$1=""; print $0}' | sed 's/^ *//')
    
    # 打印
    echo -n "$basic_info"
    echo "$first_word"
    echo "$rest_words" | tr ' ' '\n' | sed 's/^/                                                                   /'
    echo
done
```

## 方法4：最接近你要的效果

```bash
ps aux | grep obsidian | grep -v grep | while read line; do
    # 使用 awk 处理格式
    echo "$line" | awk '{
        # 打印前10个字段
        for(i=1; i<=10; i++) 
            printf "%-8s ", $i
        print ""
        
        # 分行打印命令参数
        for(i=11; i<=NF; i++) 
            printf "                                                                   %s\n", $i
        print ""
    }'
done
```

**推荐使用方法2（Python脚本）**，因为它最灵活且能准确处理各种边界情况，能产生你最想要的那种换行对齐效果。